Chapter 2 Git Basics
If you can read only one chapter to get going with Git, this is it. This chapter covers every baisc you need to do the vast majority of the things you'll eventually spend your time doing with Git.
2.1 Getting a Git Repository
Initializing a repository in an exsiting directory
go to the project's directory and tpye: $ git init
Cloning an existing repository
$ git clone <url>

2.2 Recording changes to the repository
You need to make some changes and commit snapshots of those changes into your repository each time the project reaches a state you want to record. Every file in your project has two states: tracked and untracked. Tracked means the files in your last snapshot; they can be unmodified, modified, or staged. Untracked files are everything else. When you first clone a repository, all of your files will be tracked and unmodified because Git just checke them out and you haven't editing anything.
* Checking the status of your files
$ git status
when you add a new file, it is untracked, because git sees a file you didn't have in the previous snapshot (commit)
* Tracking new files
$ git add <filename>
it's staged because it's under the "Changes to be committed" heading. If you commit at this point, the version of the file at the time you ran git add is what will be in the historical snapshot.
* Staging modified files
"changes not staged for commit" which means that a file that is tracked has been modified in the working direcotory but not yet staged. You need git add.
git add is a multipurpose command - you use it to begin tracking new files, to stage files  and to do other things like marking merge-conflicted files as resovled.
If you modify a changed and staged file again, it will show up in bot staged and unstaged. It turns out that Git stages a file exactly as it is when you run git add command. If you modify a file after you run git add, you have to run git add again to stage the latest version of the file.
* Ignoring files
.gitignore
* Viewing your staged and unstaged changes
$ git diff - use it to answer two questions: what have you changed but not yet staged? And what have you staged that you are about ot commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed. The command compares what is in your working directory with what is in your staging area. The result tells you the changes you've made that you haven't yet staged.
$ git diff --staged. This command compares your staged changes to your last commit. Use it when you want to see what you've staged that will go into next commit.
* Committing your changes
Now that your staging area is set up the way you want it, you can commit your changes. Remember that everything that is still unstaged - any files you have created or modified that haven't run git add on since you edited them - won't go into this commit.
$ git commit
$ git commit -v option puts the diff of your change in the editor so you can see exactly what changes you're committing. 
Everytime you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.
* Skipping the staging area
Adding the -a option to the git commit command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add part
* Removing files
To remove a file from Git, you have to remove it from your tracked files (more accuragely, remove it from your staging area) and then commit.
If you simiply remove the file from your working directory, it shows up under the "change but not updated" area, then if you run git rm, it stages the file's removal. The next time you commit, the file will be gone and no longer tracked.
* Moving files
* git mv file_from file_to

2.3 Viewing the commit history
